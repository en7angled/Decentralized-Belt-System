---
description: Offchain project-specific concepts (pipeline, type hierarchy, context, errors); Atlas GYTxSkeleton and monads
globs: src/lib/offchain-lib/**/*.hs
alwaysApply: false
---
# Offchain Project Rules

Offchain and TxBuilding concepts for this project. See also [project-architecture.mdc](project-architecture.mdc) for library layout and file reference.

## Pipeline

Interactions are transformed into Transactions via Operations. (1) `interactionToTxSkeleton` (Interactions) takes an `Interaction` (action + user addresses) and dispatches to Operations (e.g. `createProfileTX`, `promoteProfileTX`). (2) Operations build a `GYTxSkeleton` by composing **Skeletons** (ref inputs, validity window, CIP-68 helpers) and **Lookups** (UTxO/datum queries). (3) `interactionToTxBody` (Transactions) runs the skeleton through the builder to produce the actual transaction. Do not bypass this flow. Output order in skeleton `mconcat` must match on-chain redeemer indices; see [onchain-rules.mdc](onchain-rules.mdc) § Output layout and redeemers. Document that order in a comment when adding or changing redeemers.

## Atlas conventions (GYTxSkeleton and monads)

- **Specify-what-you-want:** Operations declare desired inputs, outputs, reference inputs, validity, and signatories; the framework handles change outputs, min ADA, collateral, and balancing. Do not manually add change or min-ADA logic in operations.
- **Monad hierarchy** (increasing capability): `GYTxQueryMonad` (queries: `scriptAddress`, `utxoDatum'`, slot/time); `GYTxUserQueryMonad` (user/wallet); `GYTxBuilderMonad` (`buildTxBody`); `GYTxMonad` (sign + submit); `GYTxGameMonad` (testing: `asUser`). Use the least capable monad that suffices for each function.
- **Skeleton helpers:** Compose with `mconcat`: `mustHaveOutput`, `mustHaveInput`, `mustHaveRefInput`, `mustBeSignedBy`, `isInvalidBefore`/`isInvalidAfter`, `mustMint`. Output order defines on-chain redeemer indices (see Pipeline and [onchain-rules.mdc](onchain-rules.mdc)).
- **Scripts:** `scriptFromPlutus` yields `GYScript v`; use `scriptAddress @_ @'PlutusV2` (or correct `PlutusVersion`). Reference script: `GYBuildPlutusScriptReference refScript script`; inlined: `GYBuildPlutusScriptInlined script`.
- **Lookups:** For script addresses, use `utxoDatum'` for one UTxO's datum; use `utxosDatums` when filtering out invalid datums at an address where anyone can create UTxOs.

## Type hierarchy

Transfer → Domain → Onchain; add new API shapes in Transfer, domain entities in Core, onchain types in `Onchain/Protocol/Types.hs` and `Id.hs`. See [project-architecture.mdc](project-architecture.mdc) and its file reference table.

## New concept

When adding a new validator, token kind, projection type, or API surface: follow the phase order (on-chain types → validator → minting redeemer → domain types → tx building → API → chain sync → admin → tests → deployment) and run the full consistency checklist. See [new-concept-checklist.mdc](../workflow/new-concept-checklist.mdc) for the detailed checklist and common pitfalls.

## DeployedScriptsContext

New validator → new field in Context, JSON config, `deployReferenceScripts` in Transactions, and `config/config_bjj_validators.json` updated after deploy. **OracleNFTPolicy is not part of DeployedScriptsContext** — it is used inlined in the single oracle-mint transaction only; do not add an oracle NFT policy ref to context. See OnchainArchitecture.md § Oracle NFT Policy: Inlined, Not Deployed.

## Errors and JSON

- **Errors**: Use `TxBuildingException` and map to HTTP status via `txBuildingExceptionToHttpStatus`; do not throw raw strings.
- **JSON**: Use `deriving-aeson` with `StripPrefix` + `CamelToSnake` for consistent snake_case API fields.

## Onchain functions used offchain

When calling onchain functions from TxBuilding (e.g. `Onchain.getCurrentRankId`, `Onchain.promoteProfile`, `Onchain.initMembershipHistory`, `Onchain.appendMembershipHistory`, `Onchain.insertMembershipHistoryInBetween`, `Onchain.addMembershipIntervalToHistory`, `Onchain.acceptMembershipInterval`, `Onchain.acceptAchievement`, `Onchain.BJJ.intToBelt`), do **not** call them directly. They can hit `traceError` or pattern-match failure and surface as raw Plutus/Haskell errors.

- **One exception per function**: For each such onchain function, there is a dedicated `TxBuildingException` constructor (e.g. `ProfileHasNoRank`, `PromotionNotPending`, `InitMembershipHistoryInvalidDates`, `MembershipListInsertInvalid`, `MembershipListAppendInvalid`, `MembershipIntervalAlreadyAccepted`, `AchievementAlreadyAccepted`, `InvalidBeltNumber`). Use these so the API can map to HTTP status and return consistent error messages.
- **Offchain analogue functions**: Call the safe wrappers in `TxBuilding.SafeOnchainLogic` instead of the raw onchain functions. Those wrappers pre-validate (or catch and map) and throw `GYApplicationException` with the corresponding `TxBuildingException`. Example: use `safeGetCurrentRankId` instead of `Onchain.getCurrentRankId`; use `safeIntToBelt` instead of `intToBelt` in Conversions.
- **Pre-validate where possible**: The safe wrappers mirror on-chain checks and throw the appropriate exception before calling the onchain function, so that invalid data never reaches `traceError`. For conditions that are expensive or impossible to replicate offchain, the wrapper may call the onchain function and rely on correct offchain construction (e.g. list invariants from `findInsertPointForNewMembership`).
